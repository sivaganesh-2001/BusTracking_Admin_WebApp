const admin = require('firebase-admin');

const serviceAccount = require('../transitrace-e6a39-firebase-adminsdk-82k0g-70df591990.json'); // Replace with your service account key file
admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: "https://transitrace-e6a39-default-rtdb.firebaseio.com" // Replace with your database URL
});

const db = admin.database();

const driverRef = db.ref('driver');
const busListRef = db.ref('bus_list');
const fs = admin.firestore();
const storage = admin.storage();


const collection1 = ['driver', 'bus_list']
const collection2=[ 'complaints', 'feedback', 'emergency'];

exports.getadmindashboard = async (req, res) => {
  try {
    const counts = {};
    const countsvalue ={};

    for (let i = 0; i < collection1.length; i++) {
      const snapshot1 = await db.ref(collection1[i]).once('value');
      counts[`count${i + 1}`] = snapshot1.numChildren();
    }

     for (let j = 0; j < collection2.length; j++) {
        const snapshot2 = await fs.collection(collection2[j]).get();
        countsvalue[`countsval${j + 1}`] = snapshot2.size;
      }

    res.render('admindashboard', { counts, countsvalue });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
};


exports.getloginpage = async(req,res)=>{
    res.render('login');
}

exports.postloginpage = async (req, res) => {
    const { username, password } = req.body;

    try {
        // Check if the email exists in the 'admin' collection in the Realtime Database
        const adminRef = db.ref('admin');
        adminRef.orderByChild('email').equalTo(username).once('value', snapshot => {
            if (snapshot.exists()) {
                snapshot.forEach(childSnapshot => {
                    const adminData = childSnapshot.val();
                    if (adminData.password === password) {
                        // Authentication successful
                        res.redirect('/dashboard');
                    } else {
                        // Incorrect password
                        res.send('Incorrect password');
                    }
                });
            } else {
                // Email not found
                res.send('Email not found');
            }
        });
    } catch (error) {
        console.error('Error:', error);
        res.status(500).send('Internal Server Error');
    }
};

      


exports.getadddriver = async (req, res) => {
  res.render('./driver/adddriver');
};

// Route to handle driver registration
exports.postadddriver = async (req, res) => {
    try {
        const { fname, lname, license, dob, phone, password } = req.body;
        if (!phone) {
            return res.status(400).json({ error: 'License is required.' });
        }
  
        // Check if the driver already exists
        const driverdetailsSnapshot = await driverRef.orderByChild('Phone').equalTo(phone).once('value');
        if (driverdetailsSnapshot.exists()) {
            return res.status(400).json({ error: 'Driver already exists.' });
        }
  
        // Add new driver
        const newdriverRef = driverRef.push();
        const driverId = newdriverRef.key; // Get the autogenerated ID of the document
        await newdriverRef.set({
            FirstName: fname,
            LastName: lname,
            LicenseNo: license,
            DOB: dob,
            Phone: phone,
            Password: password,
            id: driverId // Store the ID as a field in the document
        });
  
        return res.status(200).json({ error: 'Driver added successfully' });
    } catch (error) {
        console.error('Error adding Driver Name: ', error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
  };
  


exports.getupdatedriver = async (req, res) => {
  res.render('./driver/updatedriver', { user: null });
};

exports.getsearchdriver = async (req, res) => {
  res.render('./driver/searchdriver', { user: null });
};

exports.getdeletedriver = async (req, res) => {
  res.render('./driver/deletedriver', { user: null });
};

exports.postsearchdriver = async(req, res) => {
  const phone = req.body.phone;
  if (!phone) {
      return res.status(400).json({ error: 'Phone number is required.' });
  }

  driverRef.once('value', (snapshot) => {
      const drivers = snapshot.val();
      let foundDriver = null;

      if (drivers) {
          Object.values(drivers).forEach((driver) => {
              if (driver.Phone === phone) {
                  foundDriver = driver;
              }
          });
      }

      if (foundDriver) {
          res.render('./driver/searchdriver', { user: foundDriver });
      } else {
          res.render('./driver/searchdriver', { user: null });
      }
  });
};

exports.postsearchupdatedriver = async(req, res) => {
  const phone = req.body.phone;
  if (!phone) {
      return res.status(400).json({ error: 'Phone number is required.' });
  }

  driverRef.once('value', (snapshot) => {
      const drivers = snapshot.val();
      let foundDriver = null;

      if (drivers) {
          Object.values(drivers).forEach((driver) => {
              if (driver.Phone === phone) {
                  foundDriver = driver;
              }
          });
      }

      if (foundDriver) {
          res.render('./driver/updatedriver', { user: foundDriver });
      } else {
          res.render('./driver/updatedriver', { user: null });
      }
  });
};
 
exports.postupdatedriver = async (req, res) => {
    try {
        const updatedData = req.body;
        const phone = req.body.originalPhone;  // Assuming you're sending the original driver ID in the request body
   
        if (!phone) {
            return res.status(400).json({ error: 'Phone number is required.' });
        }
   
         // Find the driver by driver ID to get the unique key
         const driverSnapshot = await driverRef.orderByChild('Phone').equalTo(phone).once('value');
      if (!driverSnapshot.exists()) {
          return res.status(404).json({ error: 'Driver not found.' });
      }
   
         // Assuming there's only one driver with the given driver ID
         const driverKey = Object.keys(driverSnapshot.val())[0];
         await driverRef.child(driverKey).update(updatedData); // Update the driver using the unique key
   
         console.log('Driver details updated successfully:', updatedData);
         res.sendStatus(200);
    } catch (error) {
         console.error('Error updating driver details:', error);
         res.status(500).send('Internal Server Error');
    }
   };
   

exports.postsearchdeletedriver = async(req, res) => {
  const phone = req.body.phone;
  if (!phone) {
      return res.status(400).json({ error: 'Phone number is required.' });
  }

  driverRef.once('value', (snapshot) => {
      const drivers = snapshot.val();
      let foundDriver = null;

      if (drivers) {
          Object.values(drivers).forEach((driver) => {
              if (driver.Phone === phone) {
                  foundDriver = driver;
              }
          });
      }

      if (foundDriver) {
          res.render('./driver/deletedriver', { user: foundDriver });
      } else {
          res.render('./driver/deletedriver', { user: null });
      }
  });
};


exports.postdeletedriver=async (req, res) => {
  try {
    const phone = req.body.originalPhone; // Assuming you're sending the phone number in the request body
    if (!phone) {
        return res.status(400).json({ error: 'Phone number is required.' });
    }

    // Find the driver by phone number
    const driverSnapshot = await driverRef.orderByChild('Phone').equalTo(phone).once('value');
    if (!driverSnapshot.exists()) {
        return res.status(404).json({ error: 'Driver not found.' });
    }

    // Assuming there's only one driver with the given phone number
    const driverKey = Object.keys(driverSnapshot.val())[0];
    await driverRef.child(driverKey).remove(); // Delete the driver

    console.log('Driver deleted successfully');
    res.sendStatus(200);
} catch (error) {
    console.error('Error deleting driver:', error);
    res.status(500).send('Internal Server Error');
}
};

exports.getaddbus=async (req, res)=> {
  res.render('./bus/addbus')
};

exports.getsearchbus=async (req,res)=>{
  res.render('./bus/searchbus', { bus: null });
};

exports.postsearchbus=async (req, res) => {
  const busNumber = req.body.busNumber;
  if (!busNumber) {
      return res.status(400).json({ error: 'Bus number is required.' });
  }
  
  busListRef.once('value', (snapshot) => {
      const buses = snapshot.val();
      let foundBus = null;
  
      if (buses) {
          Object.values(buses).forEach((bus) => {
              if (bus.busNumber === busNumber) {
                  foundBus = bus;
              }
          });
      }
  
      if (foundBus) {
          res.render('./bus/searchbus', { bus: foundBus });
      } else {
          res.render('./bus/searchbus', { bus: null });
      }
  });
  
};

exports.getupdatebus=async (req, res) => {
  res.render('./bus/updatebus', { bus: null });
};

exports.postaddbus = async (req, res) => {
    try {
        const { busNumber, ...otherBusDetails } = req.body;

        // Check if the bus number is provided
        if (!busNumber) {
            return res.status(400).json({ error: 'Bus number is required.' });
        }

        // Check if the bus already exists
        const busDetailsSnapshot = await busListRef.orderByChild('busNumber').equalTo(busNumber).once('value');
        if (busDetailsSnapshot.exists()) {
            return res.status(400).json({ error: 'Bus already exists.' });
        }

        // Add new bus
        const newBusRef = busListRef.push();
        const busId = newBusRef.key; // Get the autogenerated ID of the document
        await newBusRef.set({
            busNumber,
            id: busId,
            ...otherBusDetails
        });

        return res.status(200).json({ message: 'Bus added successfully', busKey: busId });
    } catch (error) {
        console.error('Error adding bus: ', error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
};

exports.postsearchupdatebus=async (req, res) => {
  const busNumber = req.body.busNumber;
  if (!busNumber) {
      return res.status(400).json({ error: 'Bus number is required.' });
  }

  busListRef.once('value', (snapshot) => {
      const buses = snapshot.val();
      let foundBus = null;

      if (buses) {
          Object.values(buses).forEach((onebus) => {
              if (onebus.busNumber === busNumber) {
                  foundBus = onebus;
              }
          });
      }

      if (foundBus) {
          res.render('./bus/updatebus', { bus: foundBus });
       
      } else {
          res.render('./bus/updatebus', { bus: null });
      }
  });
};

exports.postupdatebus=async (req, res) => {
  try {
      const updatedData = req.body;
      const busNumber = req.body.originalBusNumber; // Assuming you're sending the original bus number in the request body

      if (!busNumber) {
          return res.status(400).json({ error: 'Bus number is required.' });
      }

      // Find the bus by bus number to get the unique key
      const busSnapshot = await busListRef.orderByChild('busNumber').equalTo(busNumber).once('value');
      if (!busSnapshot.exists()) {
          return res.status(404).json({ error: 'Bus not found.' });
      }

      // Assuming there's only one bus with the given bus number
      const busKey = Object.keys(busSnapshot.val())[0];
      await busListRef.child(busKey).update(updatedData); // Update the bus using the unique key

      console.log('Bus details updated successfully:', updatedData);
      res.sendStatus(200);
  } catch (error) {
      console.error('Error updating bus details:', error);
      res.status(500).send('Internal Server Error');
  }
};

exports.getdeletebus=async (req, res) => {
  res.render('./bus/deletebus',{bus:null});
};

exports.postsearchdeletebus=async (req, res) => {
  const busNumber = req.body.busNumber;
  if (!busNumber) {
      return res.status(400).json({ error: 'Bus number is required.' });
  }

  busListRef.once('value', (snapshot) => {
      const buses = snapshot.val();
      let foundBus = null;

      if (buses) {
          Object.values(buses).forEach((onebus) => {
              if (onebus.busNumber === busNumber) {
                  foundBus = onebus;
              }
          });
      }

      if (foundBus) {
          res.render('./bus/deletebus', { bus: foundBus });
       
      } else {
          res.render('./bus/deleteebus', { bus: null });
      }
  });
};

exports.postdeletebus=async (req, res) => {
  try {
      const busNumber = req.body.originalBusNumber; // Assuming you're sending the original bus number in the request body
      if (!busNumber) {
          return res.status(400).json({ error: 'Bus number is required.' });
      }

      // Find the bus by bus number
      const busSnapshot = await busListRef.orderByChild('busNumber').equalTo(busNumber).once('value');
      if (!busSnapshot.exists()) {
          return res.status(404).json({ error: 'Bus not found.' });
      }

      // Assuming there's only one bus with the given bus number
      const busKey = Object.keys(busSnapshot.val())[0];
      await busListRef.child(busKey).remove(); // Delete the bus

      console.log('Bus deleted successfully');
      res.sendStatus(200);
  } catch (error) {
      console.error('Error deleting bus:', error);
      res.status(500).send('Internal Server Error');
  }
};

exports.getcomplaints = async (req, res) => {
    try {
        const complaintsSnapshot = await fs.collection('complaints').get();
        const complaints = complaintsSnapshot.docs.map(doc => {
            const data = doc.data();
            return {
                id: doc.id,
                complaint: data.complaint || 'N/A',
                date: data.date ? new Date(data.date._seconds * 1000).toLocaleString() : 'N/A',
                location: data.location || 'N/A',
                phone: data.phone || 'N/A',
                userEmail: data.userEmail || 'N/A'
            };
        });
        res.render('complaints', { complaints });
    } catch (error) {
        console.error('Error fetching complaints:', error);
        res.status(500).send('Internal Server Error');
    }
};

   exports.getfeedback=async (req, res) => {
    try {
        const feedbackSnapshot = await fs.collection('feedback').get();
        const feedback = feedbackSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        res.render('feedback',{feedback});
    } catch (error) {
        console.error('Error fetching feedback:', error);
        res.status(500).json({ error: 'Internal Server Error', message: error.message });
    }
};

exports.getemergency=async (req, res) => {
    try {
        const emergencySnapshot = await fs.collection('emergency').get();
        const emergency = emergencySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
       // res.status(200).json({emergency});
        res.render('emergency',{emergency});
    } catch (error) {
        console.error('Error fetching feedback:', error);
        res.status(500).json({ error: 'Internal Server Error', message: error.message });
    }
};

